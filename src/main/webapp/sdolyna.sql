-- phpMyAdmin SQL Dump
-- version 4.5.5.1deb1
-- http://www.phpmyadmin.net
--
-- Host: localhost
-- Generation Time: Mar 14, 2016 at 11:22 PM
-- Server version: 5.6.28-1
-- PHP Version: 5.6.17-3

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `sdolyna`
--

-- --------------------------------------------------------

--
-- Table structure for table `sdolyna_content`
--

CREATE TABLE `sdolyna_content` (
  `article_id` int(11) NOT NULL,
  `article_category` int(11) NOT NULL,
  `article_title_ru` varchar(500) NOT NULL,
  `article_title_en` varchar(500) NOT NULL,
  `article_text_ru` text NOT NULL,
  `article_text_en` text,
  `article_date` varchar(500) DEFAULT NULL,
  `article_date_end` varchar(500) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `sdolyna_content`
--

INSERT INTO `sdolyna_content` (`article_id`, `article_category`, `article_title_ru`, `article_title_en`, `article_text_ru`, `article_text_en`, `article_date`, `article_date_end`) VALUES
(1, 0, 'Украина', 'Ukraine', 'Ukraine', 'Ukraine', NULL, ''),
(2, 0, 'Словакия', 'Slovakia', 'Словакия', 'Словакия', NULL, ''),
(3, 0, 'Венгрия', 'Hungary', 'Венгрия', 'Венгрия', NULL, ''),
(4, 0, 'Словения', 'Slovenia', 'Словения', 'Словения', NULL, ''),
(5, 0, 'Хорватия', 'Croatia', 'Хорватия', 'Хорватия', NULL, ''),
(6, 0, 'Греция', 'Greece', 'Греция', 'Греция', NULL, ''),
(7, 1, 'Test', 'Test', '<p>Android OS, если сравнить её с Windows, Linux или OSX, система молодая. Однако, ей пользуются более миллиарда человек. Как именно они работают с Android? Как сделать систему быстрее и удобнее? Новизна платформы не позволяет дать чётких ответов на эти вопросы. Более того, сценарии взаимодействия пользователей с Android-устройствами и приложениями постоянно меняются, нередко &ndash; довольно сильно и неожиданно.<br />\r\n&nbsp;</p>\r\n\r\n<p><a href="https://habrahabr.ru/company/intel/blog/279061/"><img src="https://habrastorage.org/files/b1a/e4d/6eb/b1ae4d6eb7ab42e584201ca30c68b816.jpg" /></a></p>\r\n\r\n<p><br />\r\nДля исследования особенностей взаимодействия пользователей с различными программными и аппаратными комплексами создают особые тесты, так называемые варианты или сценарии использования систем (use cases). Их ещё называют &laquo;рабочими нагрузками&raquo; (workloads). Всё это &ndash; модели реально существующих сценариев работы, настоящими приложениями они не являются. В применении к Android, подобные тесты можно использовать для измерения и улучшения производительности.<br />\r\n<a name="habracut"></a><br />\r\nК сожалению, для Android существует лишь несколько приложений, правдоподобно имитирующих реальную рабочую нагрузку. Применяемые сегодня тесты, вроде CaffeineMark, либо ничего общего с настоящими сценариями работы не имеют, либо &ndash; слишком просты. Эти тесты просто не содержат испытаний, направленных на исследование того, как устройствами пользуются на самом деле. Однако, они, в силу распространённости, сильно влияют на общественное мнение, на то, как широкая публика воспринимает те или иные устройства.&nbsp;<br />\r\n<br />\r\nКак результат, разработчики, оперируя результатами таких испытаний, не в состоянии выяснить, какие ощущения вызовет работа с тем или иным устройством у реального пользователя. Если оптимизировать систему, опираясь на подобные тесты, можно добиться впечатляющих показателей, что называется, &laquo;на бумаге&raquo; и оставить открытым главный вопрос: &laquo;А что это даст пользователям?&raquo;.</p>\r\n', '<p>Test</p>\r\n', '16.03.2016', ''),
(8, 1, 'Not A Title', 'Not A Title 2', '<p>Not A Title Text</p>\r\n', '<p>Not A Title Text 2</p>\r\n', '08.03.2016', ''),
(9, 3, 'Camp', 'Camp', '<h2>Обзор Icy Rocks</h2>\r\n\r\n<p><br />\r\nБольшинство тестов для Android исследуют систему в одном из двух основных направлений. Некоторые сконцентрированы на ограниченном наборе аппаратных особенностей устройств. Они разработаны для того, чтобы получить некие данные по конкретным компонентам или наборам компонентов SoC-платформ. Другие не привязаны к аппаратному обеспечению. Они сосредоточены на уровне Java-окружения, по факту, используя ограниченное количество функций. И те, и другие &ndash; это синтетические рабочие нагрузки, они не делают того же самого, что происходит в коде типичного реального приложения.<br />\r\n<br />\r\nСтек исполнения приложений в Android отличается сложностью, поэтому при анализе производительности этой системы стоит отойти от устаревших узконаправленных методов и переключиться на новые. На те, которые более точно отражают особенности поведения людей. Если наша цель &ndash; ощутимо улучшить восприятие приложений человеком, нужны тесты, которые реализуют реалистичные сценарии работы с системой. А именно, нужно учитывать то, как пользователь работает с приложением, и то, как приложение взаимодействует с операционной системой, и, в конечном счёте, с аппаратным обеспечением.<br />\r\n<br />\r\nIcy Rocks Workload &ndash; это графическое приложение, разработанное Intel, которое имитирует реальную игру на платформе Android. В проекте использованы физическая библиотека с открытым кодом&nbsp;<a href="http://jbox2d.org/">JBox2D</a>&nbsp;и графический движок&nbsp;<a href="https://code.google.com/p/cocos2d-android-1/">Cocos2D</a>. За вывод графики в Cocos2D отвечает OpenGL. Симуляцией перемещения объектов занимается JBox2D. На нём построена физика игрового мира, он ответственен за обновление позиций объектов и их взаимодействие.<br />\r\n<br />\r\nВ ходе теста измеряются несколько показателей. Первый &ndash; среднее количество кадров в секунду (Frames Per Second, FPS). FPS обычно используется для оценки плавности вывода графики. Среднее количество анимаций в секунду (Animation Per Second, APS) позволяет оценить производительность физического движка. Другие показатели &ndash; это среднее время обновления кадра (Frame Update Time), количество пропущенных кадров в секунду (Janks Per Second, JPS). Итоговые данные, собранные программой, выводятся на экран и записываются в лог-файл на устройстве.<br />\r\n&nbsp;</p>\r\n\r\n<h2>Симуляция игры</h2>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img src="https://habrastorage.org/getpro/habr/post_images/490/727/431/490727431d538685947a35a72e043661.png" /></p>\r\n\r\n<p><br />\r\n<em>Icy Rocks в действии</em><br />\r\n<br />\r\nГлавный экран Icy Rocks насыщен спрайтами. Здесь льдины, хлопья снега, снеговик и катапульта. Катапульта бросает в снеговика куски льда. Их разделяет ущелье, туда скатываются снежинки и льдины. В нижней части ущелья стоит вращающаяся мешалка, которая не даёт скучать всему тому, что попало на дно. Нагрузка, которую игра создаёт на систему в ходе симуляции, постепенно возрастает. Достигается это добавлением кусков льда и снежинок.<br />\r\n<br />\r\nIcy Rocks может выполняться в двух режимах. Первый &ndash; режим демонстрации, второй служит для тестирования. В демонстрационном режиме пользователь может добавлять на экран льдины и хлопья снега, касаясь экрана. В режиме тестирования всё выполняется автоматически. Куски льда и снежинки добавляются каждые 20 секунд с соотношением 2:5, программа не реагирует на касания экрана. Всего выполняется пять проходов теста, после чего выводятся итоговые результаты.<br />\r\n&nbsp;</p>\r\n\r\n<h2>Три варианта Icy Rocks</h2>\r\n\r\n<p><br />\r\nIcy Rocks существует в трёх вариантах. Первый &ndash; для платформы Android, второй &ndash; для Oracle Java (JDK 8), третий представлен нативным приложением на C++. Внешний вид и анимация во всех трёх вариантах аналогичны.&nbsp;<br />\r\n<br />\r\nКак уже было сказано, есть два режима работы программы &ndash; демонстрационный и тестовый. В демонстрационном режиме время выполнения не ограничено, в тестовом оно составляет около 11 минут.&nbsp;<br />\r\n<br />\r\nIcy Rocs для платформы Android &ndash; это эталонная реализация. Icy Rocks для Java можно запустить на любом ПК под управлением Linux с установленной Java 8. Нативный вариант Icy Rocks использует C++-версии&nbsp;<a href="http://box2d.org/">Box2D</a>&nbsp;и&nbsp;<a href="http://cocos2d-x.org/">Cocos2D-X</a>.<br />\r\n<br />\r\nIcy Rocks для Android и для Java можно запускать как в графическом режиме, так и в режиме CPU (non-GL). Последний вариант ещё называется Icy Rocks Workload for Kernel. Его применение позволяет оценить автономную производительность физического движка.<br />\r\n&nbsp;</p>\r\n\r\n<h2>Запуск Icy Rocks</h2>\r\n\r\n<p><br />\r\nIcy Rocks для Android поставляется в виде одного пакета GameWorkload.apk. После установки и запуска приложения можно выбрать режим тестирования (benchmark) или демонстрационный (demo). В режиме тестирования всё выполняется автоматически, в конце работы сообщаются результаты. В демонстрационном режиме пользователь может взаимодействовать с программой.<br />\r\n&nbsp;</p>\r\n\r\n<h2>Распределение нагрузки во времени в автоматическом режиме</h2>\r\n\r\n<p><br />\r\nВ типичной реальной игре для Android вычислительная сложность возрастает, когда пользователь достигает более высокого уровня и набирает больше очков. В Icy Rocks мы легко увеличиваем нагрузку, добавляя больше льдин и снега &ndash; это показано на иллюстрации ниже.<br />\r\n<br />\r\nIcy Rocks измеряет среднее число кадров, выводимых в секунду (FPS) при нагрузке различной интенсивности, затем вычисляется среднее геометрическое показателя на разных уровнях нагрузки. В ходе теста так же замеряется число пропущенных кадров в секунду (Jank Per Second, JPS) в различные моменты анимации. Термином &laquo;Jank&raquo; в Java-среде принято обозначать &laquo;рваную&raquo;, &laquo;скачкообразную&raquo; анимацию.&nbsp;<br />\r\n<br />\r\nТипичная продолжительность одного сеанса игры на Android &ndash; около 10 минут, поэтому тест рассчитан на выполнение примерно в течение 11 минут. Сюда входят и 10-секундные паузы между проходами теста. В рамках одного прохода нагрузка на систему, за счёт добавления кусков льда и снежинок, увеличивается. В начале на экране нет ни того, ни другого. Потом добавляется 20 льдин и 50 снежинок &ndash; и так далее. Когда нагрузка возрастает до заданного предела, делается 10-секундный перерыв и всё повторяется. Предусмотрено пять проходов теста, каждый занимает примерно две минуты. Вот как это выглядит на схеме.<br />\r\n&nbsp;</p>\r\n\r\n<p><img src="https://habrastorage.org/getpro/habr/post_images/63e/013/38f/63e01338f566b9f4db8b675bb8de07e5.png" /></p>\r\n\r\n<p><br />\r\n<em>Схема проведения тестирования</em><br />\r\n<br />\r\nПри выполнении каждого из проходов теста подсчитываются упомянутые выше показатели. А именно:<br />\r\n<br />\r\nОсновные показатели (primary metrics).<br />\r\n&mdash; Количество анимаций в секунду.<br />\r\n&mdash; Частота кадров.<br />\r\n<br />\r\nДополнительные показатели (secondary metrics).<br />\r\n&mdash; Время обновления экрана в секундах на кадр.<br />\r\n&mdash; Количество пропущенных кадров.<br />\r\n<br />\r\nПосле того, как тест завершён, выполняется вычисление среднего геометрического по результатам измерений, сделанных в каждом из пяти проходов. Итоговый результат выглядит так, как показано ниже.<br />\r\n&nbsp;</p>\r\n\r\n<p><img src="https://habrastorage.org/getpro/habr/post_images/585/e8e/794/585e8e79457fcf91a69e72e0514fb010.png" /></p>\r\n\r\n<p><br />\r\n<em>Результаты тестирования</em></p>\r\n', '', 'null', 'null'),
(10, 1, 'Test test', '', '<h2>Обзор Icy Rocks</h2>\r\n\r\n<p><br />\r\nБольшинство тестов для Android исследуют систему в одном из двух основных направлений. Некоторые сконцентрированы на ограниченном наборе аппаратных особенностей устройств. Они разработаны для того, чтобы получить некие данные по конкретным компонентам или наборам компонентов SoC-платформ. Другие не привязаны к аппаратному обеспечению. Они сосредоточены на уровне Java-окружения, по факту, используя ограниченное количество функций. И те, и другие &ndash; это синтетические рабочие нагрузки, они не делают того же самого, что происходит в коде типичного реального приложения.<br />\r\n<br />\r\nСтек исполнения приложений в Android отличается сложностью, поэтому при анализе производительности этой системы стоит отойти от устаревших узконаправленных методов и переключиться на новые. На те, которые более точно отражают особенности поведения людей. Если наша цель &ndash; ощутимо улучшить восприятие приложений человеком, нужны тесты, которые реализуют реалистичные сценарии работы с системой. А именно, нужно учитывать то, как пользователь работает с приложением, и то, как приложение взаимодействует с операционной системой, и, в конечном счёте, с аппаратным обеспечением.<br />\r\n<br />\r\nIcy Rocks Workload &ndash; это графическое приложение, разработанное Intel, которое имитирует реальную игру на платформе Android. В проекте использованы физическая библиотека с открытым кодом&nbsp;<a href="http://jbox2d.org/">JBox2D</a>&nbsp;и графический движок&nbsp;<a href="https://code.google.com/p/cocos2d-android-1/">Cocos2D</a>. За вывод графики в Cocos2D отвечает OpenGL. Симуляцией перемещения объектов занимается JBox2D. На нём построена физика игрового мира, он ответственен за обновление позиций объектов и их взаимодействие.<br />\r\n<br />\r\nВ ходе теста измеряются несколько показателей. Первый &ndash; среднее количество кадров в секунду (Frames Per Second, FPS). FPS обычно используется для оценки плавности вывода графики. Среднее количество анимаций в секунду (Animation Per Second, APS) позволяет оценить производительность физического движка. Другие показатели &ndash; это среднее время обновления кадра (Frame Update Time), количество пропущенных кадров в секунду (Janks Per Second, JPS). Итоговые данные, собранные программой, выводятся на экран и записываются в лог-файл на устройстве.<br />\r\n&nbsp;</p>\r\n\r\n<h2>Симуляция игры</h2>\r\n\r\n<p>&nbsp;</p>\r\n\r\n<p><img src="https://habrastorage.org/getpro/habr/post_images/490/727/431/490727431d538685947a35a72e043661.png" /></p>\r\n\r\n<p><br />\r\n<em>Icy Rocks в действии</em><br />\r\n<br />\r\nГлавный экран Icy Rocks насыщен спрайтами. Здесь льдины, хлопья снега, снеговик и катапульта. Катапульта бросает в снеговика куски льда. Их разделяет ущелье, туда скатываются снежинки и льдины. В нижней части ущелья стоит вращающаяся мешалка, которая не даёт скучать всему тому, что попало на дно. Нагрузка, которую игра создаёт на систему в ходе симуляции, постепенно возрастает. Достигается это добавлением кусков льда и снежинок.<br />\r\n<br />\r\nIcy Rocks может выполняться в двух режимах. Первый &ndash; режим демонстрации, второй служит для тестирования. В демонстрационном режиме пользователь может добавлять на экран льдины и хлопья снега, касаясь экрана. В режиме тестирования всё выполняется автоматически. Куски льда и снежинки добавляются каждые 20 секунд с соотношением 2:5, программа не реагирует на касания экрана. Всего выполняется пять проходов теста, после чего выводятся итоговые результаты.<br />\r\n&nbsp;</p>\r\n\r\n<h2>Три варианта Icy Rocks</h2>\r\n\r\n<p><br />\r\nIcy Rocks существует в трёх вариантах. Первый &ndash; для платформы Android, второй &ndash; для Oracle Java (JDK 8), третий представлен нативным приложением на C++. Внешний вид и анимация во всех трёх вариантах аналогичны.&nbsp;<br />\r\n<br />\r\nКак уже было сказано, есть два режима работы программы &ndash; демонстрационный и тестовый. В демонстрационном режиме время выполнения не ограничено, в тестовом оно составляет около 11 минут.&nbsp;<br />\r\n<br />\r\nIcy Rocs для платформы Android &ndash; это эталонная реализация. Icy Rocks для Java можно запустить на любом ПК под управлением Linux с установленной Java 8. Нативный вариант Icy Rocks использует C++-версии&nbsp;<a href="http://box2d.org/">Box2D</a>&nbsp;и&nbsp;<a href="http://cocos2d-x.org/">Cocos2D-X</a>.<br />\r\n<br />\r\nIcy Rocks для Android и для Java можно запускать как в графическом режиме, так и в режиме CPU (non-GL). Последний вариант ещё называется Icy Rocks Workload for Kernel. Его применение позволяет оценить автономную производительность физического движка.<br />\r\n&nbsp;</p>\r\n\r\n<h2>Запуск Icy Rocks</h2>\r\n\r\n<p><br />\r\nIcy Rocks для Android поставляется в виде одного пакета GameWorkload.apk. После установки и запуска приложения можно выбрать режим тестирования (benchmark) или демонстрационный (demo). В режиме тестирования всё выполняется автоматически, в конце работы сообщаются результаты. В демонстрационном режиме пользователь может взаимодействовать с программой.<br />\r\n&nbsp;</p>\r\n\r\n<h2>Распределение нагрузки во времени в автоматическом режиме</h2>\r\n\r\n<p><br />\r\nВ типичной реальной игре для Android вычислительная сложность возрастает, когда пользователь достигает более высокого уровня и набирает больше очков. В Icy Rocks мы легко увеличиваем нагрузку, добавляя больше льдин и снега &ndash; это показано на иллюстрации ниже.<br />\r\n<br />\r\nIcy Rocks измеряет среднее число кадров, выводимых в секунду (FPS) при нагрузке различной интенсивности, затем вычисляется среднее геометрическое показателя на разных уровнях нагрузки. В ходе теста так же замеряется число пропущенных кадров в секунду (Jank Per Second, JPS) в различные моменты анимации. Термином &laquo;Jank&raquo; в Java-среде принято обозначать &laquo;рваную&raquo;, &laquo;скачкообразную&raquo; анимацию.&nbsp;<br />\r\n<br />\r\nТипичная продолжительность одного сеанса игры на Android &ndash; около 10 минут, поэтому тест рассчитан на выполнение примерно в течение 11 минут. Сюда входят и 10-секундные паузы между проходами теста. В рамках одного прохода нагрузка на систему, за счёт добавления кусков льда и снежинок, увеличивается. В начале на экране нет ни того, ни другого. Потом добавляется 20 льдин и 50 снежинок &ndash; и так далее. Когда нагрузка возрастает до заданного предела, делается 10-секундный перерыв и всё повторяется. Предусмотрено пять проходов теста, каждый занимает примерно две минуты. Вот как это выглядит на схеме.<br />\r\n&nbsp;</p>\r\n\r\n<p><img src="https://habrastorage.org/getpro/habr/post_images/63e/013/38f/63e01338f566b9f4db8b675bb8de07e5.png" /></p>\r\n\r\n<p><br />\r\n<em>Схема проведения тестирования</em><br />\r\n<br />\r\nПри выполнении каждого из проходов теста подсчитываются упомянутые выше показатели. А именно:<br />\r\n<br />\r\nОсновные показатели (primary metrics).<br />\r\n&mdash; Количество анимаций в секунду.<br />\r\n&mdash; Частота кадров.<br />\r\n<br />\r\nДополнительные показатели (secondary metrics).<br />\r\n&mdash; Время обновления экрана в секундах на кадр.<br />\r\n&mdash; Количество пропущенных кадров.<br />\r\n<br />\r\nПосле того, как тест завершён, выполняется вычисление среднего геометрического по результатам измерений, сделанных в каждом из пяти проходов. Итоговый результат выглядит так, как показано ниже.<br />\r\n&nbsp;</p>\r\n\r\n<p><img src="https://habrastorage.org/getpro/habr/post_images/585/e8e/794/585e8e79457fcf91a69e72e0514fb010.png" /></p>\r\n\r\n<p><br />\r\n<em>Результаты тестирования</em></p>\r\n', '', '13.03.2016', '10.03.2016'),
(11, 1, '1111', '11111', '', '', '14.03.2016', ''),
(12, 1, '1111', '11111', '', '', '14.03.2016', ''),
(13, 1, '1111', '11111', '', '', '14.03.2016', ''),
(14, 1, '4', '4', '', '', '14.03.2016', ''),
(15, 1, 'adad', 'adad', '', '', '14.03.2016', ''),
(16, 1, 'adwa', '', '', '', '14.03.2016', ''),
(17, 1, 'qwereqwrqew', 'qwereqwrqew', '', '', '14.03.2016', ''),
(18, 1, 'tttt', 'tttt', '', '', '14.03.2016', ''),
(19, 1, 'erwqrqw', 'ewrewqrewq', '', '', '14.03.2016', ''),
(20, 1, 'erwqrqw', 'ewrewqrewq', '', '', '14.03.2016', ''),
(21, 1, 'rrrrrrrrr', '', '<p>В данной статье речь пойдет о числах в формате с плавающей точкой и в частности о реализации специализированного формата FP23 на программируемых логических интегральных схемах (ПЛИС). В рамках конкретного проекта у меня родилась мысль реализовать оптимальный для определенных нужд формат данных с плавающей точкой. В итоге эта мысль переросла в реальный проект, который впоследствии нашел применение в некоторых интересных задачах цифровой обработки сигналов. В статье рассмотрены основные сложности при реализации формата данных floating point на ПЛИС Xilinx, рассмотрены базовые математические операции в формате FP23. Также в конце статьи вы можете найти исходный код проекта, которой можно свободно использовать в своих задачах или на его основе реализовать похожие форматы данных.<br />\r\n<br />\r\n<img src="https://habrastorage.org/files/60f/91e/6b7/60f91e6b77404332b23fb29db343277c.png" /><br />\r\n<a name="habracut"></a><br />\r\n&nbsp;</p>\r\n\r\n<p>Формат данных</p>\r\n\r\n<p><br />\r\nЧисла с плавающей точкой активно используются в современных сигнальных процессорах, видеокартах и даже в ПЛИС. В соответствии со стандартом&nbsp;<strong>IEEE 754</strong>, они представляются в виде совокупности экспоненты (показателя степени), мантиссы и знака. Числа в стандарте IEEE 754 имеют 32 бита (<em>float</em>). Для однозначности записи числа во float записываются в нормальной форме или приводятся к нормализованному виду после математических операций и преобразований над числами. Диапазон возможных значений зависит от количества бит мантиссы и экспоненты. Для float характерна фиксированная относительная точность и переменная абсолютная точность. Основные преимущества и недостатки чисел в формате float:</p>\r\n\r\n<ul>\r\n	<li>+ Обеспечивается очень широкий диапазон возможных значений;</li>\r\n	<li>+ Достигается высокая точность вычислений;</li>\r\n	<li>&ndash; Округление очень больших чисел до возможных из сетки значений;</li>\r\n	<li>&ndash; Потеря точности при суммировании чисел, отличных друг от друга во много раз;</li>\r\n	<li>&ndash; Сложность реализации и применения на ПЛИС.</li>\r\n</ul>\r\n\r\n<p><br />\r\nДля современных микросхем ПЛИС реализация чисел в формате с плавающей точкой не составляет большого труда. Для ведущих производителей &ndash; Xilinx и Altera существуют готовые SOFT IP-ядра, реализующие float по стандарту. Для Altera в последних семействах представлены HARD IP-ядра, реализующие формат IEEE 754 на DSP-блоках.<br />\r\n&nbsp;</p>\r\n\r\n<p>Цифровая часть</p>\r\n\r\n<p><br />\r\nОсновная элементная база для выполнения математических операций и задач цифровой обработки сигналов &ndash; передовые семейства ПЛИС. Работа проводится на ПЛИС фирмы Xilinx, которые содержат блоки векторов конфигурируемых ячеек. В первую очередь это универсальные блоки цифровой обработки и математики &ndash; DSP48E1 (для ПЛИС серии Virtex-6 и 7 семейства) и DSP48E2 (для ПЛИС семейства UltraScale). Эти блоки позволяют выполнять функции сложения и вычитания чисел, сдвига и переноса, быстродействующего умножения, перемножения с накоплением (MACC), поиска контрольной суммы и т.д. На ячейках DSP48 в современных ПЛИС выполняется множество задач &ndash; разработка СIC и FIR фильтров, скоростное вычисление FFT/IFFT, реализация цифровых синтезаторов частоты (DDS и CORDIC), создание различных форматов представления данных и набора операций для них.<br />\r\n<br />\r\nВторым базовым компонентом ПЛИС является блочная память. Для ПЛИС Xilinx это ячейки RAMB36E1 (или RAMB18E1). Это элементы двухпортовой памяти, реализованные внутри кристаллов в виде столбцов идентичных блоков. Количество столбцов встроенной памяти зависит от объема кристалла. Максимальный объем блока памяти составляет 36Кбит, при этом он может быть сконфигурирован как два независимых блока по 18Кбит каждый. Память может быть использована с шириной данных от 1 до 72 разрядов. При отсутствии свободных ресурсов блочной памяти ПЛИС, можно задействовать распределенную память в специальных ячейках SLICEM. Для ПЛИС Ultrascale объем такой памяти до 512х1, с возможностью реконфигурации глубины и разрядности шины.&nbsp;</p>\r\n', '', '14.03.2016', '');

-- --------------------------------------------------------

--
-- Table structure for table `sdolyna_gallery`
--

CREATE TABLE `sdolyna_gallery` (
  `image_id` int(11) NOT NULL,
  `image_title_en` varchar(500) DEFAULT NULL,
  `image_title_ru` varchar(500) NOT NULL,
  `image_url` varchar(500) NOT NULL,
  `image_article_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `sdolyna_gallery`
--

INSERT INTO `sdolyna_gallery` (`image_id`, `image_title_en`, `image_title_ru`, `image_url`, `image_article_id`) VALUES
(1, '111111111e', '11111111r', 'files/gallery/YnPZAA6.jpg', 20),
(2, '2222222222e', '222222222222r', 'files/gallery/java-icon.png', 20),
(11, 'eeeeeeeeeeeeeee2', 'eeeeeeeeeeeee1', 'files/gallery/YnPZAA6.jpg', 21),
(12, '123e', '123', 'files/gallery/tali-zora-vas-nima-tali.jpg', 21),
(13, '4444e', '4444', 'files/gallery/java-icon.png', 21);

--
-- Indexes for dumped tables
--

--
-- Indexes for table `sdolyna_content`
--
ALTER TABLE `sdolyna_content`
  ADD PRIMARY KEY (`article_id`);

--
-- Indexes for table `sdolyna_gallery`
--
ALTER TABLE `sdolyna_gallery`
  ADD PRIMARY KEY (`image_id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `sdolyna_content`
--
ALTER TABLE `sdolyna_content`
  MODIFY `article_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=22;
--
-- AUTO_INCREMENT for table `sdolyna_gallery`
--
ALTER TABLE `sdolyna_gallery`
  MODIFY `image_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=14;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
